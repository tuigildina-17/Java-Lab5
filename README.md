Туйгильдина Динара ЛА8 (ИТ-17)
ЛАБОРАТОРНАЯ РАБОТА №5
ШАБЛОНЫ ООП И КОЛЛЕКЦИИ

ЗАДАНИЕ 1. Шаблоны
В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка
числителя и установка знаменателя.
Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного
значения.
Если раннее в вашем варианте не было Дроби, то создайте сущность Дробь со следующими
особенностями:
• Имеет числитель: целое число
• Имеет знаменатель: целое число
• Дробь может быть создана с указанием числителя и знаменателя
• Может вернуть строковое представление вида “числитель/знаменатель”
• Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не может
быть отрицательным.
• Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби
считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя.

Используемые классы и интерфейсы:
Интерфейс FractionInterface - задаёт контракт, которому должны следовать все реализации дробей
Методы интерфейса:
double getDecimalValue() - возвращает вещественное значение дроби
void setFraction(int numerator, int denominator) - устанавливает числитель и знаменатель одновременно
Класс Fraction:
Поля класса:
int numerator — числитель
int denominator — знаменатель
Методы класса:
Fraction(int numerator, int denominator) - конструктор, создающий дробь
setFraction(int numerator, int denominator) - запрещает знаменатель 0 и переносит знак в числитель, если знаменатель отрицательный
getDecimalValue() - вычисляет вещественное значение дроби
toString() - выводит дробь в виде a/b
equals() - сравнивает дроби по числителю и знаменателю
hashCode() —-обеспечивает корректную работу в коллекциях
Класс FractionCached — декоратор с кэшированием
Поля класса:
Fraction fraction - оригинальная дробь
Double cachedValue - кэш вычисленного значения
Методы класса:
FractionCached(Fraction fraction) - принимает дробь и «оборачивает» её
getDecimalValue() - вычисляет значение дроби только один раз, сохраняет результат в кэше, при повторных вызовах возвращает сохранённое значение
setFraction(int numerator, int denominator) - изменяет дробь и сбрасывает кэш
toString(), equals(), hashCode() - делегируются оригинальной дроби

Алгоритм работы:
1. Пользователь вводит числитель и знаменатель.
2. Создаётся объект Fraction — обычная дробь.
3. Эта дробь оборачивается в FractionCached, который добавляет кэширование.
4. Программа выводит дробь и её вещественное значение.
5. При повторном вызове getDecimalValue() используется кэш — вычисление не повторяется.
6. Пользователь изменяет дробь через setFraction() — кэш сбрасывается.
7. Программа снова вычисляет значение дроби.
8. Создаётся вторая дробь, и выполняется сравнение методом equals().

Тестирование:
Введите числитель: 1
Введите знаменатель: 2
Создана дробь: 1/2
Её значение = 0.5

Проверка кэширования
Повторный вызов getValue(): 0.5

Изменение числителя
Введите новый числитель: 3
Обновлённая дробь: 3/2
Новое значение = 1.5

Проверка equals()
Сравниваем 3/2 и 3/2
Результат equals(): true


ЗАДАНИЕ 2. Структурные шаблоны
Количество мяуканий.
Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих из задачи 2.5.4.
Необходимо таким образом передать кота в указанный метод, что бы после окончания его работы
узнать сколько раз мяукал кот за время его работы. На рисунке показан пример работы. Перед вызовом
метода создаем кота, отправляем ссылку на кота в метод, после окончания его работы выводим
количество мяуканий на экран. Кота изменять нельзя.
Если раннее в вашем варианте не было Кота, то создайте
1. сущность Кот, которая описывается следующим образом:
• Имеет Имя (строка)
• Для создания необходимо указать имя кота.
• Может быть приведен к текстовой форме вида: “кот: Имя”
• Может помяукать, что приводит к выводу на экран следующего текста: “Имя: мяу!”,
вызвать мяуканье можно без параметров.
2. интерфейс Мяуканье: разработайте метод, который принимает набор объектов способных
мяукать и вызывает мяуканье у каждого объекта. Мяукающие объекты должны иметь метод со
следующей сигнатурой:
public void meow();

Используемые классы и интерфейсы:
Класс Cat:
Поля класса:
String name - имя кота
Методы класса:
Конструктор Cat(String name) - создаёт кота и сохраняет его имя
void meow() - реализация интерфейса Meowable; выводит на экран строку вида: "Имя: мяу!"
toString() - возвращает строковое представление кота: "Кот по имени Имя"
Интерфейс Meowable - контракт для всех объектов, которые умеют мяукать
Метод интерфейса: void meow() - объект умеет мяукать
Класс Human - человек, считающий количество мяуканий
Поля класса:
int totalMeowCount - внутренний счётчик мяуканий
Методы класса:
makeMeow(Cat cat) - вызывает cat.meow(), увеличивает счётчик totalMeowCount++
getTotalMeowCount() - возвращает общее количество мяуканий, которые человек зафиксировал
Класс MeowCounter - вызывает meow() у всех Meowable
Метод класса:
static void makeAllMeow(Meowable[] meowables) - принимает массив объектов, реализующих Meowable, вызывает meow() у каждого объекта

Алгоритм работы:
1.Пользователь вводит имя кота.
2.Создаётся объект Cat.
3.Создаётся объект Human, который будет считать мяуканья.
4.Человек вызывает метод makeMeow() у кота несколько раз (например, 5).
5.Каждый вызов:
- заставляет кота мяукнуть,
- увеличивает счётчик у человека.
6.После завершения работы выводится:
- имя кота,
- количество мяуканий, зафиксированных человеком.
7.Дополнительно можно продемонстрировать работу MeowCounter, вызвав meow() у всех объектов Meowable.

Тестирование:
Введите имя кота:
Котя
Котя: мяу
Котя: мяу
Котя: мяу
Котя: мяу
Котя: мяу
Результат: Кот по имени Котя мяукал 5 раз(а)


ЗАДАНИЕ 3. Список
ЗАДАЧА 5. Составить программу, которая удаляет из списка L все элементы с указанным значением.

Используемые классы:
Класс ListCleaner<T>:
Поля класса: List<T> list — список элементов
Методы класса:
removeValue(T value) — удаляет все элементы, равные value
toString() — выводит список

Алгоритм работы:
1.Пользователь выбирает тип данных: строки или числа.
2.Вводит количество элементов.
3.Заполняет список.
4.Вводит значение для удаления.
5.Метод removeValue() проходит по списку и удаляет все совпадения.
6.Программа выводит обновлённый список.

Тестирование:
Выберите тип данных:
1 - строки
2 - числа
1
Сколько строк вы хотите добавить?
3
Введите строку №1:
qwerty
Введите строку №2:
qw
Введите строку №3:
zx
Введите строку, которую нужно удалить:
qw
Результат: Список: [qwerty, zx]

Выберите тип данных:
1 - строки
2 - числа
2
Сколько чисел вы хотите добавить?
3
Введите число №1:
12
Введите число №2:
2
Введите число №3:
23
Введите число, которое нужно удалить:
2
Результат: Список: [12, 23]


ЗАДАНИЕ 4. Мап
На городской олимпиаде по информатике участникам было предложено выполнить 3 задания,
каждое из которых оценивалось по 25-балльной шкале. Известно, что общее количество
участников первого тура олимпиады не превосходит 250 человек. На вход программы подаются
сведения о результатах олимпиады. В первой строке вводится количество участников N. Далее
следуют N строк, имеющих следующий формат:
<Фамилия><Имя><Баллы>
Здесь<Фамилия>– строка, состоящая не более чем из 20 символов;<Имя>– строка, состоящая не
более чем из 15 символов;<Баллы>– строка, содержащая три целых числа, разделенных
пробелом, соответствующих баллам, полученным участником за каждое задание первого тура.
При этом <Фамилия> и <Имя>, <Имя> и <Баллы> разделены одним пробелом. Примеры входных
строк:
Петрова Ольга 25 18 16
Калиниченко Иван 14 19 15
Напишите программу, которая будет выводить на экран фамилию и имя участника, набравшего
максимальное количество баллов. Если среди остальных участников есть ученики, набравшие
такое же количество баллов, то их фамилии и имена также следует вывести. При этом имена и
фамилии можно выводить в произвольном порядке.

Используемые классы:
Класс Participant:
Поля класса:
String lastName
String firstName
int s1, s2, s3
Методы класса:
getTotal() — сумма баллов
getFullName() — "Фамилия Имя"
Класс OlympiadMap:
Поля класса:
Map<String, Participant> map — хранит участников
Методы класса:
add(Participant p) — добавляет участника
getWinners() — возвращает список участников с максимальной суммой баллов

Алоритм работы:
1.Программа открывает файл.
2.Читает количество участников.
3.Для каждой строки:
- проверяет формат,
- проверяет длину имени и фамилии,
- проверяет корректность баллов,
- создаёт объект Participant,
- добавляет его в OlympiadMap.
4.Метод getWinners():
- находит максимальную сумму баллов,
- собирает всех участников с этим значением.
5.Выводит победителей.

Тестирование:
Максимальный балл: 
Беляшев Руслан - 50
Содержание текстового файла:
4
Туйгильдина Динара 12 13 14
Беляшев Руслан 14 16 20
Васнецова Мария 0 2 7
Колотилова Алиса 24 14 4


ЗАДАНИЕ 5. Сет
ЗАДАЧА 3. Файл содержит текст на русском языке. Напечатать в алфавитном порядке все согласные буквы,
которые входят ровно в одно слово.

Используемые классы:
Класс ConsonantSetProcessor:
Поля класса: String text — исходный текст
Методы класса: 
findUniqueConsonants() — возвращает множество согласных, которые встречаются ровно в одном слове

Алгоритм работы:
1.Пользователь вводит текст.
2.Текст разбивается на слова.
3.Для каждого слова собирается множество согласных.
4.Подсчитывается, в скольких словах встречается каждая согласная.
5.В результат попадают только те, что встречаются ровно в одном слове.
6.Выводятся согласные в алфавитном порядке.

Тестирование:
Введите текст:
папа хочет спать
Результат:
с х ч 


ЗАДАНИЕ 6. Очередь
ЗАДАЧА 4. Проверить равенство участка очереди с i-го по j-й элемент (i < j).

Используемые классы:
Класс QueueChecker:
Методы класса:
checkSegmentEquality(Queue<T> queue, int i, int j) - Проверяет, равны ли все элементы очереди на участке [i, j].

Алгоритм работы:
1.Пользователь вводит размер очереди.
2.Заполняет очередь числами.
3.Вводит индексы i и j.
4.Метод:
- копирует очередь,
- берёт элемент на позиции i,
- сравнивает его со всеми элементами от i+1 до j.
5.Возвращает true или false.

Тестирование:
Введите количество элементов очереди:
5
Введите элементы очереди:
1
2
2
3
4
Введите i:
1
Введите j:
2
Все элементы с 1 по 2 равны: true


ЗАДАНИЕ 7. Стрим
ЗАДАЧА 1. Необходимо написать стрим:
Дан набор объектов типа Point, необходимо взять все Point в разных координатах, убрать с
одинаковыми X,Y, отсортировать по X, отрицательные Y сделать положительными и собрать это
все в ломаную (объект типа Polyline)
Если раннее в вашем варианте не было задание с классом Point и Polyline, то написать их:
1. класс Point:
• Координата Х: число.
• Координата Y: число.
• Может возвращать текстовое представление вида “{X;Y}”.
2. класс Line (Линия), расположенная на двумерной плоскости, которая описывается:
• Координата начала: Точка
• Координата конца: Точка
• Может возвращать текстовое представление вида “Линия от {X1;Y1} до {X2;Y2}”
3. класс Polyline (Ломаная), которая будет представлять собой ломаную линию. Ломаная
линия представляет собой набор следующих характеристик:
• Имеет массив Точек, через которые линия проходит.
• Может быть приведена к строковой форме вида “Линия [Т1,T2,…,TN]”, где TN – это
результат приведения к строке Точки с номером N.

Используемые классы:
Класс Point:
Поля класса: x, y
Методы класса:
Конструктор Point(double x, double y) - создаёт точку с координатами (x, y)
double getX(), double getY() - возвращают координаты точки
toString() - выводит точку в виде {x; y}
equals(Object o) - сравнивает две точки по координатам (важно для корректной работы distinct() в Stream API)
hashCode() - обеспечивает корректную работу в коллекциях (Set, Map)
Класс Line:
Поля класса: start, end
Методы класса:
конструктор Line(Point start, Point end) - принимает начальную и конечную точки
toString() - выводит линию в виде: Линия от {x1; y1} до {x2; y2}
Класс Polyline:
Поля класса: List<Point> points  
Методы класса:
конструктор Polyline(List<Point> points) - принимает список точек
toString() - выводит ломаную в виде списка точек
Класс StreamTask:
Методы класса: buildPolyline(List<Point> points) — создаёт ломаную по правилам

Алгоритм работы:
1.Пользователь вводит количество точек.
2.Вводит координаты.
3.Стрим:
- удаляет дубликаты (distinct()),
- делает y = abs(y),
- сортирует по x,
- собирает в список,
- создаёт Polyline.
4.Выводит результат.

Тестирование:
Введите количество точек:
5
Введите точки в формате: X Y
Точка 1: 1
-1
Точка 2: 0
3
Точка 3: 3
5
Точка 4: 3
5
Точка 5: 10
0
Результат:
Линия [{0.0;3.0}, {1.0;1.0}, {3.0;5.0}, {10.0;0.0}]


ЗАДАЧА 2.  Дан текстовый файл со строками, содержащими имя человека и его номер в следующей форме:
Вася:5
Петя:3
Аня:5
Номера людей могут повторяться. У каких-то людей может не быть номера.
Необходимо написать стрим выполняющую следующее:
читаются все люди из файла, все имена приводится к нижнему регистру, но с первой буквой в
верхнем регистре, убираем из перечня всех людей без номеров, а имена оставшихся группируются
по их номеру:
[5:[Вася, Аня], 3:[Петя]]

Используемые классы:
Класс PeopleGrouper:
Методы класса: groupPeople(String filePath) — группирует имена по номеру

Алгоритм работы:
1.Читаются строки вида "Имя:Номер".
2.Имя нормализуется:
- всё в нижний регистр,
- первая буква — заглавная.
3.Строки без номера отбрасываются.
4.Стрим группирует имена по номеру.
5.Результат выводится.

Тестирование:
Группировка людей по номеру
{5=[Оля], 10=[Даша, Катя], 15=[Егор]}
Содержание текстового файла:
Даша: 10
Аня:
катя: 10
оля: 5
ЕГОР: 15
